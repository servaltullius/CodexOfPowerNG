<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Codex of Power NG</title>
    <style>
      :root {
        color-scheme: dark;
        --uiScale: 1;
        --bg: rgba(12, 12, 16, 0.82);
        --panel: rgba(255, 255, 255, 0.06);
        --border: rgba(255, 255, 255, 0.12);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.62);
        --accent: #7c5cff;
        --danger: #ff6b6b;

        /* Perf-tunable styling (helps cursor smoothness on high DPI / 4K). */
        --shadowScale: 1;
        --rowOdd: rgba(255, 255, 255, 0.03);
        --rowHover: rgba(124, 92, 255, 0.1);
        --btnHoverBorder: rgba(255, 255, 255, 0.22);
        --btnHoverBg: rgba(255, 255, 255, 0.08);
      }
      html.lowfx {
        --shadowScale: 0.35;
        --rowOdd: rgba(255, 255, 255, 0.02);
        --rowHover: rgba(124, 92, 255, 0.06);
        --btnHoverBorder: rgba(255, 255, 255, 0.18);
        --btnHoverBg: rgba(255, 255, 255, 0.06);

        /* Slightly more opaque panels reduce expensive blending in some renderers. */
        --bg: rgba(12, 12, 16, 0.92);
        --panel: rgba(255, 255, 255, 0.05);
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        background: transparent;
        color: var(--text);
        font-size: calc(14px * var(--uiScale));
      }
      .root {
        padding: calc(22px * var(--uiScale));
        width: min(98vw, 3600px);
        margin: calc(12px * var(--uiScale)) auto;
        background: rgba(12, 12, 16, 0.82);
        background: var(--bg);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        border-radius: calc(14px * var(--uiScale));
        box-shadow: 0 calc(14px * var(--uiScale) * var(--shadowScale))
          calc(60px * var(--uiScale) * var(--shadowScale)) rgba(0, 0, 0, 0.45);
        max-height: 96vh;
        overflow: auto;
      }
      h1 {
        margin: 0 0 calc(6px * var(--uiScale)) 0;
        font-size: calc(22px * var(--uiScale));
        letter-spacing: 0.2px;
      }
      p {
        margin: 0 0 calc(16px * var(--uiScale)) 0;
        color: var(--muted);
        font-size: calc(13px * var(--uiScale));
        line-height: 1.4;
      }
      .row {
        display: flex;
        gap: calc(10px * var(--uiScale));
        flex-wrap: wrap;
        margin: calc(10px * var(--uiScale)) 0 calc(16px * var(--uiScale)) 0;
      }
      button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        background: rgba(255, 255, 255, 0.06);
        background: var(--panel);
        color: rgba(255, 255, 255, 0.92);
        color: var(--text);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: calc(10px * var(--uiScale)) calc(12px * var(--uiScale));
        min-height: calc(44px * var(--uiScale));
        border-radius: calc(10px * var(--uiScale));
        cursor: pointer;
        font-weight: 600;
        font-size: calc(13px * var(--uiScale));
      }
      button.primary {
        border-color: rgba(124, 92, 255, 0.6);
        background: rgba(124, 92, 255, 0.22);
      }
      button.danger {
        border-color: rgba(255, 107, 107, 0.6);
        background: rgba(255, 107, 107, 0.18);
      }
      button:hover {
        border-color: var(--btnHoverBorder);
        background: var(--btnHoverBg);
      }
      .btnLabel {
        pointer-events: none;
      }
      .card {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        background: rgba(255, 255, 255, 0.06);
        background: var(--panel);
        border-radius: calc(12px * var(--uiScale));
        padding: calc(12px * var(--uiScale));
      }
      .card h2 {
        margin: 0 0 calc(8px * var(--uiScale)) 0;
        font-size: calc(14px * var(--uiScale));
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        font-size: calc(12px * var(--uiScale));
      }
      input {
        width: 100%;
        padding: calc(10px * var(--uiScale)) calc(12px * var(--uiScale));
        border-radius: calc(10px * var(--uiScale));
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        background: rgba(0, 0, 0, 0.25);
        color: rgba(255, 255, 255, 0.92);
        color: var(--text);
        outline: none;
        font-size: calc(13px * var(--uiScale));
      }
      select {
        width: 100%;
        padding: calc(10px * var(--uiScale)) calc(12px * var(--uiScale));
        border-radius: calc(10px * var(--uiScale));
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        background: rgba(0, 0, 0, 0.25);
        color: rgba(255, 255, 255, 0.92);
        color: var(--text);
        outline: none;
        font-size: calc(13px * var(--uiScale));
      }
      select option {
        font-size: calc(13px * var(--uiScale));
      }
      #tabSettings #setLang,
      #tabSettings #setLang option {
        font-size: calc(15px * var(--uiScale));
      }
      .keybindRow {
        display: flex;
        gap: calc(10px * var(--uiScale));
        align-items: stretch;
      }
      .keybindRow input {
        flex: 1 1 auto;
        width: auto;
      }
      .keybindRow button {
        flex: 0 0 auto;
        min-width: calc(110px * var(--uiScale));
        padding-left: calc(10px * var(--uiScale));
        padding-right: calc(10px * var(--uiScale));
      }
      #toggleKeyResolved {
        margin-top: calc(6px * var(--uiScale));
      }
      .dropdown {
        position: relative;
      }
      .dropdown > button {
        width: 100%;
        justify-content: flex-start;
        gap: calc(10px * var(--uiScale));
      }
      .dropdownMenu {
        position: absolute;
        left: 0;
        right: 0;
        top: calc(100% + calc(6px * var(--uiScale)));
        z-index: 50;
        display: none;
        background: rgba(12, 12, 16, 0.96);
        background: var(--bg);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        border-radius: calc(12px * var(--uiScale));
        box-shadow: 0 calc(10px * var(--uiScale) * var(--shadowScale))
          calc(30px * var(--uiScale) * var(--shadowScale)) rgba(0, 0, 0, 0.55);
        padding: calc(8px * var(--uiScale));
        max-height: calc(340px * var(--uiScale));
        overflow: auto;
      }
      .dropdownMenu.open {
        display: block;
      }
      .dropdownItem {
        width: 100%;
        text-align: left;
        justify-content: flex-start;
        border: 1px solid transparent;
        background: transparent;
        border-radius: calc(10px * var(--uiScale));
        padding: calc(10px * var(--uiScale)) calc(12px * var(--uiScale));
        min-height: calc(44px * var(--uiScale));
        font-size: calc(14px * var(--uiScale));
        font-weight: 700;
      }
      .dropdownItem.active {
        border-color: rgba(124, 92, 255, 0.55);
        background: rgba(124, 92, 255, 0.14);
      }
      .dropdownItem:hover {
        border-color: var(--btnHoverBorder);
        background: var(--btnHoverBg);
      }
      .small {
        font-size: calc(12px * var(--uiScale));
        color: var(--muted);
      }
      pre {
        white-space: pre-wrap;
        word-break: break-word;
        padding: calc(10px * var(--uiScale)) calc(12px * var(--uiScale));
        border-radius: calc(10px * var(--uiScale));
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        background: rgba(0, 0, 0, 0.25);
        margin: calc(10px * var(--uiScale)) 0 0 0;
      }
      .tabs {
        display: flex;
        gap: calc(8px * var(--uiScale));
        flex-wrap: wrap;
        margin: calc(12px * var(--uiScale)) 0 calc(16px * var(--uiScale)) 0;
      }
      .tabs button {
        padding: calc(8px * var(--uiScale)) calc(10px * var(--uiScale));
        border-radius: 999px;
        font-weight: 700;
      }
      .tabs button.active {
        border-color: rgba(124, 92, 255, 0.7);
        background: rgba(124, 92, 255, 0.28);
      }
      .toolbar {
        display: flex;
        gap: calc(10px * var(--uiScale));
        align-items: center;
        justify-content: space-between;
        margin: 0 0 calc(10px * var(--uiScale)) 0;
      }
      .toolbar .left {
        display: flex;
        gap: calc(10px * var(--uiScale));
        align-items: center;
        flex-wrap: wrap;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: calc(14px * var(--uiScale));
      }
      th,
      td {
        text-align: left;
        padding: calc(10px * var(--uiScale)) calc(12px * var(--uiScale));
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        vertical-align: top;
      }
      th {
        color: var(--muted);
        font-size: calc(12.5px * var(--uiScale));
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      thead th {
        background: rgba(12, 12, 16, 0.92);
      }
      tbody tr.dataRow.rowOdd {
        background: var(--rowOdd);
      }
      tbody tr.dataRow:hover {
        background: var(--rowHover);
      }
      tr.spacerRow {
        pointer-events: none;
      }
      tr.spacerRow td {
        padding: 0 !important;
        border: 0 !important;
        background: transparent !important;
      }
      #tabQuick tbody tr.dataRow {
        cursor: pointer;
      }
      #tabQuick tbody tr.dataRow.selected {
        background: rgba(124, 92, 255, 0.18);
      }

      /* Fixed row heights for virtualization (scaled). */
      #tabQuick tbody tr.dataRow {
        height: calc(78px * var(--uiScale));
      }
      #tabRegistered tbody tr.dataRow {
        height: calc(54px * var(--uiScale));
      }
      #tabQuick td:nth-child(2) {
        overflow: hidden;
      }
      #tabQuick .itemName {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      #tabQuick .small.mono {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      #tabRegistered td:nth-child(2) {
        overflow: hidden;
      }
      #tabRegistered .itemName {
        display: block;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .colCount {
        width: calc(200px * var(--uiScale));
        text-align: right;
      }
      .colAction {
        width: calc(220px * var(--uiScale));
        text-align: right;
      }
      .colAction button {
        width: 100%;
      }
      .colFormId {
        width: calc(260px * var(--uiScale));
      }
      .colGroup {
        width: calc(220px * var(--uiScale));
      }
      .itemName {
        font-size: calc(16px * var(--uiScale));
        font-weight: 800;
        letter-spacing: 0.1px;
      }
      .pill {
        display: inline-block;
        padding: calc(2px * var(--uiScale)) calc(8px * var(--uiScale));
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        background: rgba(0, 0, 0, 0.25);
        color: rgba(255, 255, 255, 0.62);
        color: var(--muted);
        font-size: calc(12px * var(--uiScale));
      }
      .pill.warn {
        border-color: rgba(255, 107, 107, 0.6);
        background: rgba(255, 107, 107, 0.15);
        color: rgba(255, 186, 186, 0.98);
      }
      .pill.ok {
        border-color: rgba(124, 92, 255, 0.65);
        background: rgba(124, 92, 255, 0.18);
        color: rgba(212, 202, 255, 0.98);
      }
      table .pill {
        max-width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .good {
        color: rgba(124, 92, 255, 0.95);
        font-weight: 800;
      }
      .toast {
        position: fixed;
        right: calc(22px * var(--uiScale));
        bottom: calc(22px * var(--uiScale));
        max-width: calc(420px * var(--uiScale));
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.14);
        color: var(--text);
        padding: calc(10px * var(--uiScale)) calc(12px * var(--uiScale));
        border-radius: calc(12px * var(--uiScale));
        box-shadow: 0 calc(14px * var(--uiScale) * var(--shadowScale))
          calc(45px * var(--uiScale) * var(--shadowScale)) rgba(0, 0, 0, 0.4);
        display: none;
      }
      .toast.show {
        display: block;
      }
      .toast .meta {
        color: var(--muted);
        font-size: calc(12px * var(--uiScale));
        margin-bottom: calc(6px * var(--uiScale));
      }
      .section {
        display: none;
      }
      .section.active {
        display: block;
      }
      #tabSettings {
        padding-bottom: calc(70px * var(--uiScale));
      }
      #tabSettings .settingsWarnBanner {
        border-color: rgba(255, 107, 107, 0.6);
        background: rgba(90, 18, 18, 0.34);
      }
      #tabSettings .settingsWarnBanner h2 {
        color: rgba(255, 186, 186, 0.98);
      }
      #tabSettings .settingsWarnBanner .small {
        color: rgba(255, 220, 220, 0.92);
      }
      #tabSettings .settingsActions {
        position: sticky;
        bottom: calc(-12px * var(--uiScale));
        z-index: 20;
        margin: calc(12px * var(--uiScale)) 0 0 0;
        padding: calc(10px * var(--uiScale));
        border-radius: calc(12px * var(--uiScale));
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        background: rgba(12, 12, 16, 0.94);
      }
      .grid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: calc(12px * var(--uiScale));
      }
      label.inline {
        display: flex;
        align-items: center;
        gap: calc(10px * var(--uiScale));
        font-size: calc(13px * var(--uiScale));
      }
      label.inline input[type="checkbox"] {
        width: auto;
      }
      .modal-overlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.55);
      }
      .rewardViz {
        margin: 0 0 calc(12px * var(--uiScale)) 0;
        padding: calc(12px * var(--uiScale));
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-color: var(--border);
        border-radius: calc(12px * var(--uiScale));
        background: rgba(0, 0, 0, 0.2);
      }
      .rewardDiagram {
        position: relative;
        width: min(calc(760px * var(--uiScale)), 100%);
        min-height: calc(430px * var(--uiScale));
        margin: 0 auto;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: calc(12px * var(--uiScale));
        background:
          radial-gradient(circle at 50% 50%, rgba(124, 92, 255, 0.12), rgba(124, 92, 255, 0.02) 42%, transparent 68%),
          linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(0, 0, 0, 0.12));
        overflow: hidden;
      }
      .rewardRing {
        position: absolute;
        left: 50%;
        top: 50%;
        width: calc(300px * var(--uiScale));
        height: calc(300px * var(--uiScale));
        transform: translate(-50%, -50%);
        border-radius: 50%;
        border: 1px dashed rgba(255, 255, 255, 0.22);
        pointer-events: none;
      }
      .rewardCharacterWrap {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: calc(250px * var(--uiScale));
        max-width: min(42vw, calc(300px * var(--uiScale)));
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #rewardCharacterImg {
        display: block;
        width: 100%;
        height: auto;
        object-fit: contain;
        filter: drop-shadow(0 calc(8px * var(--uiScale)) calc(16px * var(--uiScale)) rgba(0, 0, 0, 0.45));
      }
      .rewardImageFallback {
        display: none;
        width: 100%;
        text-align: center;
        padding: calc(10px * var(--uiScale));
        border: 1px dashed rgba(255, 255, 255, 0.2);
        border-radius: calc(10px * var(--uiScale));
        background: rgba(0, 0, 0, 0.24);
      }
      .rewardImageFallback.show {
        display: block;
      }
      #rewardOrbit {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .rewardEffectNode {
        position: absolute;
        transform: translate(-50%, -50%);
        width: var(--rewardNodeWidth, clamp(132px, 18vw, 208px));
      }
      .rewardEffectBadge {
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: calc(10px * var(--uiScale));
        background: rgba(12, 12, 16, 0.9);
        box-shadow: 0 calc(8px * var(--uiScale) * var(--shadowScale))
          calc(24px * var(--uiScale) * var(--shadowScale)) rgba(0, 0, 0, 0.35);
        padding: calc(8px * var(--uiScale)) calc(10px * var(--uiScale));
      }
      .rewardEffectBadge .name {
        display: block;
        font-size: calc(12.5px * var(--uiScale));
        font-weight: 700;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .rewardEffectBadge .value {
        display: block;
        margin-top: calc(4px * var(--uiScale));
        font-size: calc(12px * var(--uiScale));
        color: rgba(124, 92, 255, 0.95);
        text-align: right;
      }
      .rewardEffectBadge.rewardMore {
        text-align: center;
        font-weight: 700;
        color: var(--muted);
      }
      .rewardOrbitEmpty {
        position: absolute;
        left: 50%;
        top: 85%;
        transform: translate(-50%, -50%);
        text-align: center;
      }
      .rewardVizHelp {
        margin-top: calc(10px * var(--uiScale));
        text-align: center;
      }
      @media (max-width: 980px) {
        .rewardDiagram {
          min-height: calc(520px * var(--uiScale));
        }
        .rewardEffectNode {
          width: var(--rewardNodeWidth, clamp(122px, 45vw, 182px));
        }
      }
    </style>
  </head>
  <body>
    <div class="root">
      <h1 data-i18n="app.title">Codex of Power NG</h1>
      <p data-i18n="app.desc">
        Quick Register consumes 1 item and permanently records it. Use Settings to configure safety and rewards.
      </p>

      <div class="toolbar">
        <div class="left">
          <span class="pill" id="status">UI: ...</span>
          <span class="pill" id="counts">Registered: 0</span>
          <span class="pill" id="lang">Lang: ...</span>
          <span class="pill mono" id="hotkey">Hotkey: ...</span>
          <span class="pill mono" id="inputScale">Input: 1.00</span>
          <span class="pill" id="lotdGate" style="display: none">LOTD: ...</span>
        </div>
        <div class="left">
          <button id="btnRefreshState"><span class="btnLabel" data-i18n="btn.refresh">Refresh</span></button>
          <button class="primary" id="btnClose"><span class="btnLabel" data-i18n="btn.close">Close</span></button>
        </div>
      </div>

      <div class="tabs">
        <button class="active" data-tab="tabQuick"><span class="btnLabel" data-i18n="tab.quick">Quick Register</span></button>
        <button data-tab="tabRegistered"><span class="btnLabel" data-i18n="tab.registered">Registered</span></button>
        <button data-tab="tabRewards"><span class="btnLabel" data-i18n="tab.rewards">Rewards</span></button>
        <button data-tab="tabSettings"><span class="btnLabel" data-i18n="tab.settings">Settings</span></button>
      </div>

      <div class="card section active" id="tabQuick">
        <div class="toolbar">
          <div class="left" style="flex: 1">
            <input id="quickFilter" placeholder="Search..." data-i18n-placeholder="placeholder.search" />
          </div>
          <div class="left">
            <span class="pill" id="invMeta">Inventory: -</span>
            <select id="invPageSize" style="width: calc(132px * var(--uiScale))">
              <option value="100" data-i18n="inv.pagesize.100">100 / page</option>
              <option value="200" selected data-i18n="inv.pagesize.200">200 / page</option>
              <option value="300" data-i18n="inv.pagesize.300">300 / page</option>
              <option value="400" data-i18n="inv.pagesize.400">400 / page</option>
            </select>
            <button id="btnInvPrev"><span class="btnLabel" data-i18n="btn.prev">Prev</span></button>
            <button id="btnInvNext"><span class="btnLabel" data-i18n="btn.next">Next</span></button>
            <button id="btnRefreshInv"><span class="btnLabel" data-i18n="btn.refresh">Refresh</span></button>
          </div>
        </div>
        <table>
          <thead>
            <tr>
              <th class="colGroup" data-i18n="th.group">Group</th>
              <th data-i18n="th.item">Item</th>
              <th class="colCount" data-i18n="th.count">Count</th>
              <th class="colAction"></th>
            </tr>
          </thead>
          <tbody id="quickBody"></tbody>
        </table>
        <div class="small" style="margin-top: 10px" data-i18n="quick.help">
          Only shows items safe to consume (not worn; optionally not favorited). List is paginated to avoid stutter.
        </div>
      </div>

      <div class="card section" id="tabRegistered">
        <div class="toolbar">
          <div class="left" style="flex: 1">
            <input id="regFilter" placeholder="Search..." data-i18n-placeholder="placeholder.search" />
          </div>
          <div class="left">
            <button id="btnRefreshReg"><span class="btnLabel" data-i18n="btn.refreshList">Refresh List</span></button>
          </div>
        </div>
        <table>
          <thead>
            <tr>
              <th class="colGroup" data-i18n="th.group">Group</th>
              <th data-i18n="th.item">Item</th>
              <th class="colFormId mono">FormID</th>
            </tr>
          </thead>
          <tbody id="regBody"></tbody>
        </table>
      </div>

      <div class="card section" id="tabRewards">
        <div class="toolbar">
          <div class="left">
            <span class="pill" id="rewardMeta">...</span>
          </div>
          <div class="left">
            <button id="btnRefreshRewards"><span class="btnLabel" data-i18n="btn.refresh">Refresh</span></button>
            <button id="btnRecoverCarryWeight"><span class="btnLabel" data-i18n="btn.recoverCarryWeight">Recover Carry +5</span></button>
            <button class="danger" id="btnRefundRewards"><span class="btnLabel" data-i18n="btn.refund">Refund</span></button>
          </div>
        </div>
        <div class="rewardViz">
          <div class="rewardDiagram">
            <div class="rewardRing"></div>
            <div class="rewardCharacterWrap">
              <img id="rewardCharacterImg" src="assets/character.png" alt="Reward character" />
              <div class="rewardImageFallback small" id="rewardImageFallback" data-i18n="rewards.imageMissing">
                Character image missing: assets/character.png
              </div>
            </div>
            <div id="rewardOrbit"></div>
          </div>
          <div class="small rewardVizHelp" data-i18n="rewards.orbitHelp">Top reward effects are shown around the character.</div>
        </div>
        <table>
          <thead>
            <tr>
              <th data-i18n="th.reward">Reward</th>
              <th class="colCount" data-i18n="th.total">Total</th>
            </tr>
          </thead>
          <tbody id="rewardsBody"></tbody>
        </table>
        <div class="small" style="margin-top: 10px" data-i18n="rewards.help">
          Refund removes only recorded bonus stats. It does not restore consumed items and does not clear registrations.
        </div>
        <div class="small" style="margin-top: 6px" data-i18n="rewards.recoverCarryHelp">
          Recover Carry +5 is a one-time fallback for old saves where carry reward was not recorded.
        </div>
      </div>

      <div class="card section" id="tabSettings">
        <div class="card settingsWarnBanner" id="lotdGateWarnBanner" style="display: none">
          <h2 data-i18n="settings.lotdGateWarnTitle">LOTD gate warning</h2>
          <div class="small" data-i18n="settings.lotdGateWarnBody">
            LOTD Display gate is enabled, but TCC lists are unavailable. Registration is currently blocked for safety.
          </div>
        </div>
        <div style="height: 12px"></div>
        <div class="grid2">
          <div>
            <div class="small" data-i18n-html="settings.toggleKeyHelp">
              Toggle key code (DIK). Example: <span class="mono">0x3E</span> (F4)
            </div>
            <div style="height: 8px"></div>
            <div class="keybindRow">
              <input id="setToggleKey" class="mono" placeholder="F4" />
              <button id="btnCaptureToggleKey" class="mono" type="button"><span class="btnLabel" data-i18n="btn.bindKey">Bind…</span></button>
            </div>
            <div class="small" id="toggleKeyResolved">...</div>
          </div>
          <div>
            <div class="small" data-i18n="settings.languageOverride">Language override</div>
            <div style="height: 8px"></div>
            <div class="dropdown" id="langDropdown">
              <button id="langBtn" type="button">
                <span id="langBtnLabel">auto</span>
                <span style="margin-left: auto; opacity: 0.7">▾</span>
              </button>
              <div class="dropdownMenu" id="langMenu"></div>
              <select id="setLang" style="display: none">
                <option value="auto" data-i18n="lang.auto">auto</option>
                <option value="en" data-i18n="lang.en">en</option>
                <option value="ko" data-i18n="lang.ko">ko</option>
              </select>
            </div>
          </div>
        </div>

        <div style="height: 12px"></div>
        <div class="card">
          <h2 data-i18n="settings.uiTitle">UI</h2>
          <label class="inline"><input type="checkbox" id="setPauseGame" /> <span data-i18n="settings.pauseGame">Pause game while menu is open</span></label>
          <div style="height: 10px"></div>
          <label class="inline"><input type="checkbox" id="setDisableFocusMenu" /> <span data-i18n="settings.disableFocusMenu">Disable FocusMenu overlay (advanced)</span></label>
          <div class="small" style="margin-top: 8px">
            <span data-i18n="settings.disableFocusMenuHelp">
              If the menu shows but you cannot interact (no cursor), keep this OFF. Turning it ON may prevent cursor/input capture.
            </span>
          </div>
          <div style="height: 10px"></div>
          <label class="inline"><input type="checkbox" id="setDestroyOnClose" /> <span data-i18n="settings.destroyOnClose">Destroy view on close (performance)</span></label>
          <div class="small" style="margin-top: 8px" data-i18n="settings.destroyOnCloseHelp">
            If FPS drops persist after closing the UI, keep this ON. Turning it OFF keeps UI state but may cost performance.
          </div>
          <div style="height: 14px"></div>
          <h2 data-i18n="settings.uiSizeTitle">UI Size</h2>
          <div class="grid2">
            <div>
              <div class="small" data-i18n="settings.uiSizeMode">Mode</div>
              <div style="height: 8px"></div>
              <select id="setUiScaleMode">
                <option value="auto" data-i18n="settings.uiSizeAuto">Auto (Recommended)</option>
                <option value="manual" data-i18n="settings.uiSizeManual">Manual</option>
              </select>
            </div>
            <div>
              <div class="small" data-i18n="settings.uiSizeManualScale">Manual scale</div>
              <div style="height: 8px"></div>
              <input id="setUiScaleNumber" type="number" min="1" max="3" step="0.05" />
            </div>
          </div>
          <div style="height: 10px"></div>
          <input id="setUiScaleRange" type="range" min="1" max="3" step="0.05" />
          <div class="small" style="margin-top: 8px" data-i18n-html="settings.uiSizeTip">
            Tip: 4K users often prefer <span class="mono">2.0~2.6</span>. This setting affects only this UI.
          </div>

          <div style="height: 14px"></div>
          <h2 data-i18n="settings.perfTitle">Performance</h2>
          <div class="grid2">
            <div>
              <div class="small" data-i18n="settings.perfMode">Performance mode</div>
              <div style="height: 8px"></div>
              <select id="setPerfMode">
                <option value="auto" data-i18n="settings.perfAuto">Auto (Recommended)</option>
                <option value="off" data-i18n="settings.perfOff">Off</option>
                <option value="on" data-i18n="settings.perfOn">On (Smooth cursor)</option>
              </select>
            </div>
            <div class="small" style="align-self: end" data-i18n="settings.perfHelp">
              Reduces shadows and hover effects to improve cursor smoothness.
            </div>
          </div>

          <div style="height: 14px"></div>
          <h2 data-i18n="settings.inputTitle">Input</h2>
          <div class="small" data-i18n="settings.inputScaleHelp">
            If clicks don't match the cursor (high DPI / Windows scaling), set Input scale to your scaling factor (e.g. 1.75 or 2.00). Press 0 to reset.
          </div>
          <div style="height: 10px"></div>
          <div class="grid2">
            <div>
              <div class="small" data-i18n="settings.inputScale">Input scale</div>
              <div style="height: 8px"></div>
              <input id="setInputScaleNumber" type="number" min="0.5" max="3" step="0.05" />
            </div>
            <div>
              <div class="small" data-i18n="settings.inputScalePreset">Preset</div>
              <div style="height: 8px"></div>
              <select id="setInputScalePreset">
                <option value="1">1.00 (100%)</option>
                <option value="1.25">1.25 (125%)</option>
                <option value="1.5">1.50 (150%)</option>
                <option value="1.75">1.75 (175%)</option>
                <option value="2">2.00 (200%)</option>
              </select>
            </div>
          </div>
          <div style="height: 10px"></div>
          <input id="setInputScaleRange" type="range" min="0.5" max="3" step="0.05" />
          <div class="small" style="margin-top: 8px" data-i18n-html="settings.inputScaleTip">
            Tip: Use <span class="mono">[</span>/<span class="mono">]</span> to adjust when mouse clicking is difficult. Press <span class="mono">0</span> to reset.
          </div>
        </div>
        <div style="height: 12px"></div>
        <div class="grid2">
          <div class="card">
            <h2 data-i18n="settings.safetyTitle">Safety</h2>
            <label class="inline"><input type="checkbox" id="setProtectFav" /> <span data-i18n="settings.protectFavorites">Protect favorited/hotkey items</span></label>
            <div style="height: 10px"></div>
            <label class="inline"><input type="checkbox" id="setNormalize" /> <span data-i18n="settings.normalizeRegistration">Normalize registration (template/variant map)</span></label>
            <div style="height: 10px"></div>
            <label class="inline"><input type="checkbox" id="setRequireTccDisplayed" /> <span data-i18n="settings.requireTccDisplayed">LOTD items: require Displayed (Curator's Companion)</span></label>
            <div class="small" style="margin-top: 8px" data-i18n="settings.requireTccDisplayedHelp">
              Applies to LOTD/TCC-tracked items. If TCC lists are unavailable, registration is blocked for safety.
            </div>
            <div style="height: 10px"></div>
            <label class="inline"><input type="checkbox" id="setLootNotify" /> <span data-i18n="settings.lootNotify">Loot notification</span></label>
          </div>
          <div class="card">
            <h2 data-i18n="settings.rewardsTitle">Rewards</h2>
            <label class="inline"><input type="checkbox" id="setRewardsEnabled" /> <span data-i18n="settings.enableRewards">Enable rewards</span></label>
            <div style="height: 10px"></div>
            <div class="small" data-i18n="settings.rewardEvery">Every</div>
            <input id="setRewardEvery" type="number" min="1" step="1" />
            <div style="height: 10px"></div>
            <div class="small" data-i18n="settings.rewardMultiplier">Multiplier</div>
            <input id="setRewardMult" type="number" min="0" step="0.1" />
            <div style="height: 10px"></div>
            <label class="inline"><input type="checkbox" id="setSkillRewards" /> <span data-i18n="settings.allowSkillRewards">Allow skill rewards</span></label>
          </div>
        </div>

        <div style="height: 12px"></div>
        <div class="row settingsActions">
          <button id="btnReloadSettings"><span class="btnLabel" data-i18n="btn.reload">Reload</span></button>
          <button class="primary" id="btnSaveSettings"><span class="btnLabel" data-i18n="btn.save">Save</span></button>
          <button id="btnCloseSettings"><span class="btnLabel" data-i18n="btn.close">Close</span></button>
        </div>
      </div>
    </div>

    <div class="toast" id="toast">
      <div class="meta" id="toastMeta">info</div>
      <div id="toastMsg"></div>
    </div>

    <div class="modal-overlay" id="confirmOverlay" style="display:none">
      <div class="card" style="max-width: calc(420px * var(--uiScale)); margin: auto">
        <p id="confirmMsg"></p>
        <div class="row" style="justify-content: flex-end">
          <button id="confirmCancel"><span class="btnLabel" data-i18n="btn.cancel">Cancel</span></button>
          <button class="danger" id="confirmOk"><span class="btnLabel" data-i18n="btn.ok">OK</span></button>
        </div>
      </div>
    </div>

    <script src="keycodes.js"></script>
    <script src="lang_ui.js"></script>
    <script src="virtual_tables.js"></script>
    <script src="ui_wiring.js"></script>
    <script src="interop_bridge.js"></script>
    <script src="input_shortcuts.js"></script>
    <script src="reward_orbit.js"></script>
    <script src="input_correction.js"></script>
    <script>
      const rootScrollEl = document.querySelector(".root");
      const statusEl = document.getElementById("status");
      const countsEl = document.getElementById("counts");
      const langEl = document.getElementById("lang");
      const hotkeyEl = document.getElementById("hotkey");
      const inputScalePillEl = document.getElementById("inputScale");
      const lotdGatePillEl = document.getElementById("lotdGate");
      const lotdGateWarnBannerEl = document.getElementById("lotdGateWarnBanner");

      const KC = window.COPNG_KEYCODES || null;
      const LANGUI = window.COPNG_LANGUI || null;
      const toggleKeyResolvedEl = document.getElementById("toggleKeyResolved");
      const btnCaptureToggleKeyEl = document.getElementById("btnCaptureToggleKey");
      let captureToggleKey = false;

      const langSelectEl = document.getElementById("setLang");
      const langBtnEl = document.getElementById("langBtn");
      const langBtnLabelEl = document.getElementById("langBtnLabel");
      const langMenuEl = document.getElementById("langMenu");
      let langMenuOpen = false;

      const uiScaleModeEl = document.getElementById("setUiScaleMode");
      const uiScaleRangeEl = document.getElementById("setUiScaleRange");
      const uiScaleNumberEl = document.getElementById("setUiScaleNumber");
      const perfModeEl = document.getElementById("setPerfMode");

      const inputScaleRangeEl = document.getElementById("setInputScaleRange");
      const inputScaleNumberEl = document.getElementById("setInputScaleNumber");
      const inputScalePresetEl = document.getElementById("setInputScalePreset");

      const quickBody = document.getElementById("quickBody");
      const invMetaEl = document.getElementById("invMeta");
      const invPageSizeEl = document.getElementById("invPageSize");
      const btnInvPrev = document.getElementById("btnInvPrev");
      const btnInvNext = document.getElementById("btnInvNext");
      const regBody = document.getElementById("regBody");
      const rewardsBody = document.getElementById("rewardsBody");
      const rewardMeta = document.getElementById("rewardMeta");
      const rewardOrbitEl = document.getElementById("rewardOrbit");
      const rewardCharacterImgEl = document.getElementById("rewardCharacterImg");
      const rewardImageFallbackEl = document.getElementById("rewardImageFallback");

      const toastEl = document.getElementById("toast");
      const toastMetaEl = document.getElementById("toastMeta");
      const toastMsgEl = document.getElementById("toastMsg");
      let toastTimer = null;
      let lotdGateBlockingToastShown = false;

      const I18N = {
        en: {
          "app.title": "Codex of Power NG",
          "app.desc": "Quick Register consumes 1 item and permanently records it. Use Settings to configure safety and rewards.",
          "btn.refresh": "Refresh",
          "btn.refreshList": "Refresh List",
          "btn.close": "Close",
          "btn.prev": "Prev",
          "btn.next": "Next",
          "btn.register": "Register",
          "btn.recoverCarryWeight": "Recover Carry +5",
          "btn.refund": "Refund",
          "btn.reload": "Reload",
          "btn.save": "Save",
          "btn.bindKey": "Bind…",
          "tab.quick": "Quick Register",
          "tab.registered": "Registered",
          "tab.rewards": "Rewards",
          "tab.settings": "Settings",
          "placeholder.search": "Search...",
          "th.group": "Group",
          "th.item": "Item",
          "th.count": "Count",
          "th.reward": "Reward",
          "th.total": "Total",
          "rewards.rolls": "Rolls",
          "rewards.every": "Every",
          "rewards.mult": "Mult",
          "rewards.none": "(No rewards yet)",
          "rewards.imageMissing": "Character image missing: assets/character.png",
          "rewards.orbitHelp": "Top reward effects are shown around the character.",
          "rewards.more": "+{n} more",
          "quick.help":
            "Only shows items safe to consume (not worn; optionally not favorited). List is paginated to avoid stutter. Click a row to select, then press Enter to register.",
          "rewards.help": "Refund removes only recorded bonus stats. It does not restore consumed items and does not clear registrations.",
          "rewards.recoverCarryHelp": "Recover Carry +5 is a one-time fallback for old saves where carry reward was not recorded.",
          "settings.toggleKeyHelp":
            "Toggle key. Click <span class=\"mono\">Bind…</span> then press a key, or type: <span class=\"mono\">F4</span> / <span class=\"mono\">E</span> / <span class=\"mono\">1</span> / <span class=\"mono\">0x3E</span>",
          "settings.resolved": "Resolved",
          "settings.invalid": "invalid",
          "settings.languageOverride": "Language override",
          "lang.auto": "auto (game)",
          "lang.en": "en (English)",
          "lang.ko": "ko (Korean)",
          "settings.uiTitle": "UI",
          "settings.pauseGame": "Pause game while menu is open",
          "settings.disableFocusMenu": "Disable FocusMenu overlay (advanced)",
          "settings.disableFocusMenuHelp":
            "If the menu shows but you cannot interact (no cursor), keep this OFF. Turning it ON may prevent cursor/input capture.",
          "settings.destroyOnClose": "Destroy view on close (performance)",
          "settings.destroyOnCloseHelp":
            "If FPS drops persist after closing the UI, keep this ON. Turning it OFF keeps UI state but may cost performance.",
          "settings.uiSizeTitle": "UI Size",
          "settings.uiSizeMode": "Mode",
          "settings.uiSizeAuto": "Auto (Recommended)",
          "settings.uiSizeManual": "Manual",
          "settings.uiSizeManualScale": "Manual scale",
          "settings.uiSizeTip": "Tip: 4K users often prefer <span class=\"mono\">2.0~2.6</span>. This setting affects only this UI.",
          "settings.perfTitle": "Performance",
          "settings.perfMode": "Performance mode",
          "settings.perfAuto": "Auto (Recommended)",
          "settings.perfOff": "Off",
          "settings.perfOn": "On (Smooth cursor)",
          "settings.perfHelp": "Reduces shadows and hover effects to improve cursor smoothness.",
          "settings.inputTitle": "Input",
          "settings.inputScaleHelp":
            "If clicks don't match the cursor (high DPI / Windows scaling), set Input scale to your scaling factor (e.g. 1.75 or 2.00). Press 0 to reset.",
          "settings.inputScale": "Input scale",
          "settings.inputScalePreset": "Preset",
          "settings.inputScaleTip":
            "Tip: Use <span class=\"mono\">[</span>/<span class=\"mono\">]</span> to adjust when mouse clicking is difficult. Press <span class=\"mono\">0</span> to reset.",
          "settings.safetyTitle": "Safety",
          "settings.protectFavorites": "Protect favorited/hotkey items",
          "settings.normalizeRegistration": "Normalize registration (template/variant map)",
          "settings.requireTccDisplayed": "LOTD items: require Displayed (Curator's Companion)",
          "settings.requireTccDisplayedHelp": "Applies to LOTD/TCC-tracked items. If TCC lists are unavailable, registration is blocked for safety.",
          "settings.lootNotify": "Loot notification",
          "settings.rewardsTitle": "Rewards",
          "settings.enableRewards": "Enable rewards",
          "settings.rewardEvery": "Every",
          "settings.rewardMultiplier": "Multiplier",
          "settings.allowSkillRewards": "Allow skill rewards",
          "inv.pagesize.100": "100 / page",
          "inv.pagesize.200": "200 / page",
          "inv.pagesize.300": "300 / page",
          "inv.pagesize.400": "400 / page",
          "toast.info": "info",
          "toast.error": "error",
          "toast.warn": "warning",
          "toast.bindKey": "Press a key to bind (Esc cancels).",
          "toast.bindKeyUnknown": "Unsupported key. Type a DIK code (e.g. 0x3E).",
          "toast.bindKeySet": "Hotkey set",
          "toast.lotdGateBlocked": "LOTD Display gate is enabled, but TCC lists are unavailable. Registration is blocked.",
          "confirm.refund": "Refund rewards? This cannot be undone.",
          "confirm.recoverCarryWeight":
            "Apply one-time carry recovery (+5)? Use this only if older rewards were not recorded.",
          "btn.cancel": "Cancel",
          "btn.ok": "OK",
          "status.ui": "UI",
          "status.loading": "loading",
          "status.ready": "ready",
          "status.hidden": "hidden",
          "status.shown": "shown",
          "status.focus": "focus",
          "status.noFocus": "no-focus",
          "status.registered": "Registered",
          "status.lang": "Lang",
          "status.hotkey": "Hotkey",
          "status.lotdGate": "LOTD Gate",
          "status.lotdOk": "TCC ready",
          "status.lotdBlocked": "TCC missing",
          "settings.lotdGateWarnTitle": "LOTD gate warning",
          "settings.lotdGateWarnBody":
            "LOTD Display gate is enabled, but TCC lists are unavailable. Registration is currently blocked for safety.",
          "inv.inventory": "Inventory",
          "inv.page": "page",
          "inv.showing": "showing",
          "inv.total": "total",
          "inv.none": "(No items)",
          "reg.none": "(No registered items)",
          "inv.unknown": "unknown",
        },
        ko: {
          "app.title": "코덱스 오브 파워 NG",
          "app.desc": "빠른 등록은 아이템 1개를 소비하고 영구적으로 기록합니다. 설정에서 안전장치/보상을 조정하세요.",
          "btn.refresh": "새로고침",
          "btn.refreshList": "목록 새로고침",
          "btn.close": "닫기",
          "btn.prev": "이전",
          "btn.next": "다음",
          "btn.register": "등록",
          "btn.recoverCarryWeight": "소지무게 +5 복구",
          "btn.refund": "환불",
          "btn.reload": "다시 불러오기",
          "btn.save": "저장",
          "btn.bindKey": "키 지정…",
          "tab.quick": "빠른 등록",
          "tab.registered": "등록됨",
          "tab.rewards": "보상",
          "tab.settings": "설정",
          "placeholder.search": "검색...",
          "th.group": "분류",
          "th.item": "아이템",
          "th.count": "개수",
          "th.reward": "보상",
          "th.total": "합계",
          "rewards.rolls": "횟수",
          "rewards.every": "N개마다",
          "rewards.mult": "배수",
          "rewards.none": "(아직 받은 보상이 없습니다)",
          "rewards.imageMissing": "캐릭터 이미지 없음: assets/character.png",
          "rewards.orbitHelp": "상위 보상 효과를 캐릭터 주변에 표시합니다.",
          "rewards.more": "+{n}개 더",
          "quick.help":
            "소비해도 안전한 아이템만 표시합니다(착용 중 제외, 즐겨찾기 보호는 설정). 렉 방지를 위해 페이지네이션됩니다. 행을 클릭해 선택한 뒤 Enter로 등록할 수 있습니다.",
          "rewards.help": "환불은 기록된 보너스 스탯만 제거합니다. 소비한 아이템은 복구되지 않으며, 등록 기록도 지워지지 않습니다.",
          "rewards.recoverCarryHelp": "소지무게 +5 복구는 구버전 저장에서 소지무게 보상이 기록되지 않았을 때 쓰는 1회 복구 기능입니다.",
          "settings.toggleKeyHelp":
            "토글 키. <span class=\"mono\">키 지정…</span>을 누르고 원하는 키를 누르거나, 직접 입력: <span class=\"mono\">F4</span> / <span class=\"mono\">E</span> / <span class=\"mono\">1</span> / <span class=\"mono\">0x3E</span>",
          "settings.resolved": "해석",
          "settings.invalid": "유효하지 않음",
          "settings.languageOverride": "언어 강제",
          "lang.auto": "자동(게임)",
          "lang.en": "영어(en)",
          "lang.ko": "한국어(ko)",
          "settings.uiTitle": "UI",
          "settings.pauseGame": "메뉴가 열려있는 동안 게임 일시정지",
          "settings.disableFocusMenu": "FocusMenu 오버레이 비활성화(고급)",
          "settings.disableFocusMenuHelp":
            "메뉴는 보이는데 조작이 안 된다면(커서 없음) 이 옵션을 끄세요. 켜면 커서/입력 캡처가 안 될 수 있습니다.",
          "settings.destroyOnClose": "닫을 때 뷰 제거(성능)",
          "settings.destroyOnCloseHelp":
            "UI를 닫아도 프레임드랍이 남으면 이 옵션을 켜세요. 끄면 UI 상태를 유지하지만 성능에 영향이 있을 수 있습니다.",
          "settings.uiSizeTitle": "UI 크기",
          "settings.uiSizeMode": "모드",
          "settings.uiSizeAuto": "자동(권장)",
          "settings.uiSizeManual": "수동",
          "settings.uiSizeManualScale": "수동 배율",
          "settings.uiSizeTip": "팁: 4K 사용자는 보통 <span class=\"mono\">2.0~2.6</span>를 선호합니다. 이 설정은 이 UI에만 적용됩니다.",
          "settings.perfTitle": "성능",
          "settings.perfMode": "성능 모드",
          "settings.perfAuto": "자동(권장)",
          "settings.perfOff": "끄기",
          "settings.perfOn": "켜기(부드러운 커서)",
          "settings.perfHelp": "그림자/호버 효과를 줄여 커서 움직임을 부드럽게 합니다.",
          "settings.inputTitle": "입력",
          "settings.inputScaleHelp":
            "커서와 클릭 위치가 어긋나면(고DPI/윈도우 배율) 입력 배율을 윈도우 배율(예: 1.75 또는 2.00)로 설정하세요. 0을 누르면 초기화됩니다.",
          "settings.inputScale": "입력 배율",
          "settings.inputScalePreset": "프리셋",
          "settings.inputScaleTip":
            "팁: 마우스 클릭이 어렵다면 <span class=\"mono\">[</span>/<span class=\"mono\">]</span>로 배율을 조정할 수 있습니다. <span class=\"mono\">0</span>을 누르면 초기화됩니다.",
          "settings.safetyTitle": "안전",
          "settings.protectFavorites": "즐겨찾기/단축키 아이템 보호",
          "settings.normalizeRegistration": "등록 정규화(템플릿/변형 맵)",
          "settings.requireTccDisplayed": "LOTD 물품은 Displayed(큐레이터 컴패니언)일 때만 등록",
          "settings.requireTccDisplayedHelp": "LOTD/TCC 추적 대상에 적용되며, TCC 리스트를 찾지 못하면 안전을 위해 등록이 차단됩니다.",
          "settings.lootNotify": "루팅 알림",
          "settings.rewardsTitle": "보상",
          "settings.enableRewards": "보상 활성화",
          "settings.rewardEvery": "N개마다",
          "settings.rewardMultiplier": "배수",
          "settings.allowSkillRewards": "스킬 보상 허용",
          "inv.pagesize.100": "100 / 페이지",
          "inv.pagesize.200": "200 / 페이지",
          "inv.pagesize.300": "300 / 페이지",
          "inv.pagesize.400": "400 / 페이지",
          "toast.info": "알림",
          "toast.error": "오류",
          "toast.warn": "경고",
          "toast.bindKey": "키를 눌러 지정하세요 (Esc 취소).",
          "toast.bindKeyUnknown": "지원하지 않는 키입니다. DIK 코드를 입력하세요(예: 0x3E).",
          "toast.bindKeySet": "단축키 설정",
          "toast.lotdGateBlocked": "LOTD 전시 게이트가 켜져 있지만 TCC 리스트를 찾지 못했습니다. 등록이 차단됩니다.",
          "confirm.refund": "보상을 환불할까요? 되돌릴 수 없습니다.",
          "confirm.recoverCarryWeight":
            "소지무게 1회 복구(+5)를 적용할까요? 구버전 보상이 기록되지 않은 경우에만 사용하세요.",
          "btn.cancel": "취소",
          "btn.ok": "확인",
          "status.ui": "UI",
          "status.loading": "로딩",
          "status.ready": "준비됨",
          "status.hidden": "숨김",
          "status.shown": "표시",
          "status.focus": "포커스",
          "status.noFocus": "포커스 없음",
          "status.registered": "등록됨",
          "status.lang": "언어",
          "status.hotkey": "단축키",
          "status.lotdGate": "LOTD 게이트",
          "status.lotdOk": "TCC 준비됨",
          "status.lotdBlocked": "TCC 없음",
          "settings.lotdGateWarnTitle": "LOTD 게이트 경고",
          "settings.lotdGateWarnBody":
            "LOTD 전시 게이트가 켜져 있지만 TCC 리스트를 찾지 못했습니다. 안전을 위해 현재 등록이 차단됩니다.",
          "inv.inventory": "인벤토리",
          "inv.page": "페이지",
          "inv.showing": "표시",
          "inv.total": "전체",
          "inv.none": "(아이템이 없습니다)",
          "reg.none": "(등록된 아이템이 없습니다)",
          "inv.unknown": "알 수 없음",
        },
      };

      let uiLang = "en";
      function t(key, fallback) {
        const table = (uiLang && I18N[uiLang]) || I18N.en;
        if (table && Object.prototype.hasOwnProperty.call(table, key)) return table[key];
        return fallback !== undefined ? fallback : key;
      }
      function tFmt(key, fallback, vars) {
        const base = String(t(key, fallback));
        if (!vars || typeof vars !== "object") return base;
        return base.replace(/\{([a-zA-Z0-9_]+)\}/g, (m, k) => (Object.prototype.hasOwnProperty.call(vars, k) ? String(vars[k]) : m));
      }

      function sanitizeI18nHtml(raw) {
        return String(raw)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/&lt;(\/?(span|br)\b[^&]*?)&gt;/gi, "<$1>");
      }

      function applyI18n() {
        document.querySelectorAll("[data-i18n-html]").forEach((el) => {
          const key = el.getAttribute("data-i18n-html");
          if (!key) return;
          el.innerHTML = sanitizeI18nHtml(t(key, el.innerHTML));
        });
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const key = el.getAttribute("data-i18n");
          if (!key) return;
          el.textContent = t(key, el.textContent);
        });
        document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
          const key = el.getAttribute("data-i18n-placeholder");
          if (!key) return;
          el.setAttribute("placeholder", t(key, el.getAttribute("placeholder") || ""));
        });

        // Dynamic labels (not driven by data-i18n)
        syncLangDropdown();
        updateToggleKeyResolved();
        renderRewards();
      }

      const QUICK_ROW_BASE_PX = 78;
      const REG_ROW_BASE_PX = 54;
      const VIRTUAL_OVERSCAN = 15;
      const VIRTUAL_MIN_ROWS = 24;
      const virtualTablesApi = (typeof window !== "undefined" && window.COPNGVirtualTables) || null;
      const uiWiringApi = (typeof window !== "undefined" && window.COPNGUIWiring) || null;
      const interopBridgeApi = (typeof window !== "undefined" && window.COPNGInteropBridge) || null;
      const inputShortcutsApi = (typeof window !== "undefined" && window.COPNGInputShortcuts) || null;
      const rewardOrbitApi = (typeof window !== "undefined" && window.COPNGRewardOrbit) || null;
      const inputCorrectionApi = (typeof window !== "undefined" && window.COPNGInputCorrection) || null;

      let state = {};
      let inventoryPage = { page: 0, pageSize: 200, total: 0, hasMore: false, items: [] };
      let quickSelectedId = 0;
      let quickVisibleIds = [];
      const quickVirtual = { rows: [], lastStart: -1, lastEnd: -1, tbodyTopPx: NaN, rowHeightPx: 0 };
      let registered = [];
      const regVirtual = { rows: [], lastStart: -1, lastEnd: -1, tbodyTopPx: NaN, rowHeightPx: 0 };
      let rewards = { totals: [] };
      let settings = null;

      const UI_SCALE_MODE_KEY = "copng.ui.scaleMode";
      const UI_SCALE_MANUAL_KEY = "copng.ui.manualScale";
      let uiScaleMode = "auto"; // "auto" | "manual"
      let uiScaleManual = 1.0;

      // Performance mode (cursor smoothness)
      const PERF_MODE_KEY = "copng.ui.perfMode";
      let perfMode = "auto"; // "auto" | "off" | "on"

      // Input coordinate correction (high DPI / Windows scaling)
      const INPUT_SCALE_KEY = "copng.ui.inputScale";
      let inputScale = 1.0;
      let inputScaleHasLocal = false;

      function loadInputScalePref() {
        try {
          const storedRaw = String(localStorage.getItem(INPUT_SCALE_KEY) || "");
          const stored = parseFloat(storedRaw);
          if (isFinite(stored) && stored > 0) {
            inputScale = clamp(stored, 0.5, 3.0);
            inputScaleHasLocal = true;
          }
        } catch {}
      }

      function saveInputScalePref() {
        try {
          localStorage.setItem(INPUT_SCALE_KEY, String(inputScale));
        } catch {}
      }

      function syncInputScaleControls() {
        if (inputScaleRangeEl) inputScaleRangeEl.value = String(clamp(inputScale, 0.5, 3.0));
        if (inputScaleNumberEl) inputScaleNumberEl.value = String(Math.round(clamp(inputScale, 0.5, 3.0) * 100) / 100);
        if (inputScalePresetEl) {
          const presets = [1.0, 1.25, 1.5, 1.75, 2.0];
          let nearest = presets[0];
          let best = Math.abs(inputScale - nearest);
          for (const p of presets) {
            const d = Math.abs(inputScale - p);
            if (d < best) {
              best = d;
              nearest = p;
            }
          }
          inputScalePresetEl.value = String(nearest);
        }
        if (inputScalePillEl) inputScalePillEl.textContent = `Input: ${inputScale.toFixed(2)}`;
      }

      function setInputScale(next, { persist = true, toast = false } = {}) {
        const v = parseFloat(String(next));
        if (!isFinite(v) || v <= 0) return;
        inputScale = clamp(v, 0.5, 3.0);
        inputScaleHasLocal = true;
        if (persist) saveInputScalePref();
        syncInputScaleControls();
        if (uiScaleMode === "auto") scheduleAutoUiScale();
        applyPerfModeFromPrefs();
        if (toast) showToast("info", `Input scale: ${inputScale.toFixed(2)}`);
      }

      function loadPerfModePref() {
        try {
          const stored = String(localStorage.getItem(PERF_MODE_KEY) || "auto");
          perfMode = stored === "on" || stored === "off" ? stored : "auto";
        } catch {
          perfMode = "auto";
        }
      }

      function savePerfModePref() {
        try {
          localStorage.setItem(PERF_MODE_KEY, perfMode);
        } catch {}
      }

      function getEffectiveDpr() {
        const w = Number(window.innerWidth || 0);
        const h = Number(window.innerHeight || 0);
        const dpr = Number(window.devicePixelRatio || 1);
        const sw = Number((window.screen && window.screen.width) || 0);
        const sh = Number((window.screen && window.screen.height) || 0);

        const dprRaw = isFinite(dpr) && dpr > 0 ? dpr : 1;
        const dprHint = isFinite(inputScale) && inputScale > 0 ? inputScale : 1;

        const screenScaleW = sw > 0 && w > 0 ? sw / w : 1;
        const screenScaleH = sh > 0 && h > 0 ? sh / h : 1;
        const screenScale = Math.max(screenScaleW, screenScaleH);

        let effectiveDpr = dprRaw;
        if (effectiveDpr < 1.01) {
          if (isFinite(screenScale) && screenScale > 1.01) effectiveDpr = Math.max(effectiveDpr, screenScale);
          if (dprHint > 1.01) effectiveDpr = Math.max(effectiveDpr, dprHint);
        }
        return clamp(effectiveDpr, 1.0, 3.0);
      }

      function shouldEnableLowFx() {
        if (perfMode === "on") return true;
        if (perfMode === "off") return false;

        const scale = getCurrentUiScale();
        const effectiveDpr = getEffectiveDpr();
        return scale >= 2.0 || effectiveDpr >= 1.6;
      }

      function applyPerfModeFromPrefs() {
        document.documentElement.classList.toggle("lowfx", shouldEnableLowFx());
      }

      loadInputScalePref();
      loadPerfModePref();

      function safeCall(name, payloadObj) {
        const fn = window[name];
        if (typeof fn !== "function") {
          console.warn("[copng] missing native function: " + name);
          return;
        }
        fn(JSON.stringify(payloadObj || {}));
      }

      function toHex32(v) {
        const n = Number(v >>> 0);
        let hex = n.toString(16).toUpperCase();
        while (hex.length < 8) hex = "0" + hex;
        return "0x" + hex;
      }

      function coalesce(v, fallback) {
        return v === undefined || v === null ? fallback : v;
      }

      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function getOffsetTopInRoot(rootEl, el) {
        if (!rootEl || !el || !rootEl.getBoundingClientRect || !el.getBoundingClientRect) return 0;
        const rr = rootEl.getBoundingClientRect();
        const re = el.getBoundingClientRect();
        return Number(re.top || 0) - Number(rr.top || 0) + Number(rootEl.scrollTop || 0);
      }

      let keyNavRaf = 0;
      const VIRTUAL_RENDER_THROTTLE_MS = 32; // ~30fps cap for scroll-driven renders
      let virtualTablesManager = null;

      function ensureVirtualTablesManager() {
        if (virtualTablesManager) return virtualTablesManager;
        if (!virtualTablesApi || typeof virtualTablesApi.createVirtualTableManager !== "function") return null;

        virtualTablesManager = virtualTablesApi.createVirtualTableManager({
          rootScrollEl,
          quickBody,
          regBody,
          quickVirtual,
          regVirtual,
          quickRowBasePx: QUICK_ROW_BASE_PX,
          regRowBasePx: REG_ROW_BASE_PX,
          overscan: VIRTUAL_OVERSCAN,
          minRows: VIRTUAL_MIN_ROWS,
          renderThrottleMs: VIRTUAL_RENDER_THROTTLE_MS,
          getCurrentUiScale,
          getQuickSelectedId: () => quickSelectedId,
          escapeHtml,
          t,
          coalesce,
          toHex32,
          clamp,
          documentObj: document,
          requestAnimationFrameFn: requestAnimationFrame,
        });

        return virtualTablesManager;
      }

      function scheduleVirtualRender({ force = false } = {}) {
        const mgr = ensureVirtualTablesManager();
        if (!mgr) return;
        mgr.scheduleVirtualRender({ force });
      }

      function resetVirtualWindow(v) {
        const mgr = ensureVirtualTablesManager();
        if (mgr) {
          mgr.resetVirtualWindow(v);
          return;
        }
        if (!v) return;
        v.lastStart = -1;
        v.lastEnd = -1;
        v.tbodyTopPx = NaN;
      }

      function schedulePostRefreshVirtualResync() {
        const mgr = ensureVirtualTablesManager();
        if (mgr) {
          mgr.schedulePostRefreshVirtualResync();
          return;
        }
        scheduleVirtualRender({ force: true });
        requestAnimationFrame(() => scheduleVirtualRender({ force: true }));
      }

      // Auto UI scaling (resolution aware)
      let uiScaleTimer = null;
      function getCurrentUiScale() {
        const raw = String(getComputedStyle(document.documentElement).getPropertyValue("--uiScale") || "").trim();
        const v = parseFloat(raw);
        return isFinite(v) && v > 0 ? v : 1;
      }

      function computeAutoUiScale() {
        const w = Number(window.innerWidth || 0);
        const h = Number(window.innerHeight || 0);
        const sw = Number((window.screen && window.screen.width) || 0);
        const sh = Number((window.screen && window.screen.height) || 0);
        const effectiveDpr = getEffectiveDpr();
        const viewportPx = Math.min(w, h) * effectiveDpr;
        const screenPx = Math.min(sw, sh);
        const minDim = Math.max(viewportPx, screenPx);
        if (!isFinite(minDim) || minDim <= 0) return 1;

        // Base on 1080p vertical; 4K typically lands around ~2.0x.
        const ratio = minDim / 1080;
        const scale = Math.max(0.0, ratio);
        return clamp(scale, 1.0, 3.0);
      }

      function loadUiScalePrefs() {
        try {
          const mode = String(localStorage.getItem(UI_SCALE_MODE_KEY) || "auto");
          uiScaleMode = mode === "manual" ? "manual" : "auto";

          const stored = parseFloat(String(localStorage.getItem(UI_SCALE_MANUAL_KEY) || ""));
          uiScaleManual = isFinite(stored) && stored > 0 ? clamp(stored, 1.0, 3.0) : 1.9;
        } catch {
          uiScaleMode = "auto";
          uiScaleManual = 1.9;
        }
      }

      function saveUiScalePrefs() {
        try {
          localStorage.setItem(UI_SCALE_MODE_KEY, uiScaleMode);
          localStorage.setItem(UI_SCALE_MANUAL_KEY, String(uiScaleManual));
        } catch {}
      }

      function syncUiScaleControls() {
        if (!uiScaleModeEl || !uiScaleRangeEl || !uiScaleNumberEl) return;

        uiScaleModeEl.value = uiScaleMode;

        const manualEnabled = uiScaleMode === "manual";
        uiScaleRangeEl.disabled = !manualEnabled;
        uiScaleNumberEl.disabled = !manualEnabled;

        const shown = manualEnabled ? uiScaleManual : getCurrentUiScale();
        uiScaleRangeEl.value = String(clamp(shown, 1.0, 3.0));
        uiScaleNumberEl.value = String(Math.round(clamp(shown, 1.0, 3.0) * 100) / 100);
      }

      function applyManualUiScale() {
        document.documentElement.style.setProperty("--uiScale", String(clamp(uiScaleManual, 1.0, 3.0)));
        scheduleVirtualRender({ force: true });
      }

      function applyUiScaleFromPrefs() {
        if (uiScaleMode === "manual") {
          applyManualUiScale();
          syncUiScaleControls();
          applyPerfModeFromPrefs();
          safeCall("copng_log", { level: "info", message: `UI scale -> ${getCurrentUiScale().toFixed(3)} (manual)` });
          return;
        }

        applyAutoUiScale();
        syncUiScaleControls();
        applyPerfModeFromPrefs();
      }

      function applyAutoUiScale() {
        if (uiScaleMode !== "auto") return;

        const w = Number(window.innerWidth || 0);
        const h = Number(window.innerHeight || 0);
        const dpr = Number(window.devicePixelRatio || 1);
        const sw = Number((window.screen && window.screen.width) || 0);
        const sh = Number((window.screen && window.screen.height) || 0);
        const dprRaw = isFinite(dpr) && dpr > 0 ? dpr : 1;
        const dprHint = isFinite(inputScale) && inputScale > 0 ? inputScale : 1;
        const screenScaleW = sw > 0 && w > 0 ? sw / w : 1;
        const screenScaleH = sh > 0 && h > 0 ? sh / h : 1;
        const screenScale = Math.max(screenScaleW, screenScaleH);
        const effectiveDpr = getEffectiveDpr();
        const scale = computeAutoUiScale();
        document.documentElement.style.setProperty("--uiScale", String(scale));
        safeCall("copng_log", {
          level: "info",
          message: `UI scale -> ${scale.toFixed(3)} (viewport ${w}x${h}, screen ${sw}x${sh}, dpr ${dprRaw} (effective ${effectiveDpr}, screenScale ${screenScale.toFixed(
            2
          )}, inputScale ${dprHint}))`,
        });

        applyPerfModeFromPrefs();
        scheduleVirtualRender({ force: true });
      }

      function scheduleAutoUiScale() {
        if (uiScaleMode !== "auto") return;
        if (uiScaleTimer) clearTimeout(uiScaleTimer);
        uiScaleTimer = setTimeout(applyAutoUiScale, 150);
      }

      function showToast(level, message) {
        if (toastTimer) clearTimeout(toastTimer);
        const lvl = String(level || "info").toLowerCase();
        toastMetaEl.textContent = t("toast." + lvl, lvl);
        toastMsgEl.textContent = message || "";
        toastEl.classList.add("show");
        toastTimer = setTimeout(() => toastEl.classList.remove("show"), 2500);
      }

      function showConfirm(message) {
        return new Promise((resolve) => {
          const overlay = document.getElementById("confirmOverlay");
          const msgEl = document.getElementById("confirmMsg");
          const okBtn = document.getElementById("confirmOk");
          const cancelBtn = document.getElementById("confirmCancel");
          if (!overlay || !msgEl || !okBtn || !cancelBtn) { resolve(false); return; }
          msgEl.textContent = message || "";
          overlay.style.display = "";
          function cleanup(result) {
            overlay.style.display = "none";
            okBtn.removeEventListener("click", onOk);
            cancelBtn.removeEventListener("click", onCancel);
            resolve(result);
          }
          function onOk() { cleanup(true); }
          function onCancel() { cleanup(false); }
          okBtn.addEventListener("click", onOk);
          cancelBtn.addEventListener("click", onCancel);
        });
      }

      function getToggleKeyDik() {
        if (settings && isFinite(settings.toggleKeyCode)) return (settings.toggleKeyCode >>> 0) & 0xff;
        if (state && isFinite(state.toggleKeyCode)) return (state.toggleKeyCode >>> 0) & 0xff;
        return 0x3e;
      }

      function formatToggleKeyLabel(dik) {
        const name = KC && KC.dikToKeyName ? KC.dikToKeyName(dik) : null;
        if (name) return name;
        const hex = KC && KC.dikToHex ? KC.dikToHex(dik) : null;
        return hex || toHex32(dik >>> 0);
      }

      function formatToggleKeyDisplay(dik) {
        const formatted = KC && KC.formatDikDisplay ? KC.formatDikDisplay(dik) : null;
        if (formatted) return formatted;
        const hex = KC && KC.dikToHex ? KC.dikToHex(dik) : null;
        return hex || toHex32(dik >>> 0);
      }

      function updateToggleKeyResolved() {
        if (!toggleKeyResolvedEl) return;
        const raw = (document.getElementById("setToggleKey").value || "").trim();
        const parsed = KC && KC.parseKeybindInput ? KC.parseKeybindInput(raw) : null;
        if (parsed == null) {
          toggleKeyResolvedEl.textContent = `${t("settings.resolved", "Resolved")}: ${t("settings.invalid", "invalid")}`;
          return;
        }
        toggleKeyResolvedEl.textContent = `${t("settings.resolved", "Resolved")}: ${formatToggleKeyDisplay(parsed)}`;
      }

      function setToggleKeyInputFromDik(dik) {
        const input = document.getElementById("setToggleKey");
        if (!input) return;
        input.value = formatToggleKeyLabel(dik);
        updateToggleKeyResolved();
      }

      function closeLangMenu() {
        langMenuOpen = false;
        if (langMenuEl) langMenuEl.classList.remove("open");
      }

      function syncLangDropdown() {
        if (!langSelectEl || !langBtnLabelEl) return;
        const v = LANGUI && LANGUI.normalizeLanguageValue ? LANGUI.normalizeLanguageValue(langSelectEl.value) : (langSelectEl.value || "auto");
        if (langSelectEl.value !== v) langSelectEl.value = v;
        langBtnLabelEl.textContent = t("lang." + v, v);
      }

      function openLangMenu() {
        if (!langMenuEl) return;
        const items = LANGUI && LANGUI.getLanguageItems ? LANGUI.getLanguageItems(t) : [
          { value: "auto", label: t("lang.auto", "auto") },
          { value: "en", label: t("lang.en", "en") },
          { value: "ko", label: t("lang.ko", "ko") },
        ];

        const current = langSelectEl ? String(langSelectEl.value || "auto") : "auto";

        langMenuEl.innerHTML = items
          .map((it) => {
            const active = it.value === current;
            const cls = "dropdownItem" + (active ? " active" : "");
            return `<button type="button" class="${cls}" data-value="${escapeHtml(it.value)}">${escapeHtml(it.label)}</button>`;
          })
          .join("");

        langMenuEl.querySelectorAll("button[data-value]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const v = btn.getAttribute("data-value") || "auto";
            if (langSelectEl) langSelectEl.value = v;
            syncLangDropdown();
            closeLangMenu();
          });
        });

        langMenuOpen = true;
        langMenuEl.classList.add("open");
      }

      function setTab(tabId) {
        document.querySelectorAll(".tabs button").forEach((btn) => btn.classList.toggle("active", btn.dataset.tab === tabId));
        document.querySelectorAll(".section").forEach((sec) => sec.classList.toggle("active", sec.id === tabId));
        scheduleVirtualRender({ force: true });
      }

      function renderStatus() {
        const ui = state.ui || {};
        statusEl.textContent = `${t("status.ui", "UI")}: ${ui.ready ? t("status.ready", "ready") : t("status.loading", "loading")} | ${
          ui.hidden ? t("status.hidden", "hidden") : t("status.shown", "shown")
        } | ${ui.focused ? t("status.focus", "focus") : t("status.noFocus", "no-focus")}`;
        countsEl.textContent = `${t("status.registered", "Registered")}: ${coalesce(state.registeredCount, 0)}`;
        langEl.textContent = `${t("status.lang", "Lang")}: ${coalesce(state.language, "?")}`;
        hotkeyEl.textContent = `${t("status.hotkey", "Hotkey")}: ${formatToggleKeyDisplay(coalesce(state.toggleKeyCode, 0) >>> 0)}`;
        if (inputScalePillEl) inputScalePillEl.textContent = `Input: ${inputScale.toFixed(2)}`;

        if (lotdGatePillEl) {
          const gate = (state && state.lotdGate) || {};
          const enabled = !!gate.requireTccDisplayed;
          const blocking = !!gate.blocking;

          if (!enabled) {
            lotdGatePillEl.style.display = "none";
            lotdGatePillEl.classList.remove("warn", "ok");
            lotdGateBlockingToastShown = false;
          } else {
            lotdGatePillEl.style.display = "";
            lotdGatePillEl.classList.toggle("warn", blocking);
            lotdGatePillEl.classList.toggle("ok", !blocking);
            lotdGatePillEl.textContent = `${t("status.lotdGate", "LOTD Gate")}: ${
              blocking ? t("status.lotdBlocked", "TCC missing") : t("status.lotdOk", "TCC ready")
            }`;

            if (blocking && !lotdGateBlockingToastShown) {
              showToast("warn", t("toast.lotdGateBlocked", "LOTD Display gate is enabled, but TCC lists are unavailable. Registration is blocked."));
              lotdGateBlockingToastShown = true;
            } else if (!blocking) {
              lotdGateBlockingToastShown = false;
            }
          }
        }

        if (lotdGateWarnBannerEl) {
          const gate = (state && state.lotdGate) || {};
          const enabled = !!gate.requireTccDisplayed;
          const blocking = !!gate.blocking;
          lotdGateWarnBannerEl.style.display = enabled && blocking ? "" : "none";
        }
      }

      function renderQuickVirtual({ force = false } = {}) {
        const mgr = ensureVirtualTablesManager();
        if (!mgr) return;
        mgr.renderQuickVirtual({ force });
      }

      function renderRegisteredVirtual({ force = false } = {}) {
        const mgr = ensureVirtualTablesManager();
        if (!mgr) return;
        mgr.renderRegisteredVirtual({ force });
      }

      function renderQuick() {
        const q = (document.getElementById("quickFilter").value || "").toLowerCase();
        const items = (inventoryPage && inventoryPage.items) || [];
        const rows = items.filter((it) => !q || (it.name || "").toLowerCase().indexOf(q) !== -1);
        quickVirtual.rows = rows;
        quickVisibleIds = rows.map((it) => (Number(it.formId) >>> 0));
        if (quickSelectedId && quickVisibleIds.indexOf(quickSelectedId) === -1) {
          quickSelectedId = 0;
        }
        scheduleVirtualRender({ force: true });

        const page = coalesce(inventoryPage.page, 0);
        const pageSize = coalesce(inventoryPage.pageSize, 0);
        const total = coalesce(inventoryPage.total, 0);
        const totalPages = total > 0 && pageSize > 0 ? Math.max(1, Math.ceil(total / pageSize)) : 0;
        if (invMetaEl) {
          const pagesText = totalPages > 0 ? `${page + 1}/${totalPages}` : `${page + 1}/${t("inv.unknown", "unknown")}`;
          const totalText = total > 0 ? String(total) : t("inv.unknown", "unknown");
          invMetaEl.textContent = `${t("inv.inventory", "Inventory")}: ${t("inv.page", "page")} ${pagesText} (${t(
            "inv.showing",
            "showing"
          )} ${rows.length}/${items.length}, ${t("inv.total", "total")} ${totalText})`;
        }
        if (invPageSizeEl) {
          const shownSize = String(pageSize > 0 ? pageSize : 200);
          if (invPageSizeEl.value !== shownSize) {
            invPageSizeEl.value = shownSize;
          }
        }
        if (btnInvPrev) btnInvPrev.disabled = page <= 0;
        if (btnInvNext) {
          btnInvNext.disabled = totalPages > 0 ? page + 1 >= totalPages : !inventoryPage.hasMore;
        }
      }

      function renderRegistered() {
        const q = (document.getElementById("regFilter").value || "").toLowerCase();
        const rows = registered.filter((it) => !q || (it.name || "").toLowerCase().indexOf(q) !== -1);
        regVirtual.rows = rows;
        scheduleVirtualRender({ force: true });
      }

      function syncRewardCharacterImageState() {
        if (rewardOrbitApi && typeof rewardOrbitApi.syncRewardCharacterImageState === "function") {
          rewardOrbitApi.syncRewardCharacterImageState({
            characterImgEl: rewardCharacterImgEl,
            fallbackEl: rewardImageFallbackEl,
          });
          return;
        }
        if (!rewardCharacterImgEl || !rewardImageFallbackEl) return;
        const loaded = !!(rewardCharacterImgEl.complete && rewardCharacterImgEl.naturalWidth > 0);
        rewardCharacterImgEl.style.display = loaded ? "" : "none";
        rewardImageFallbackEl.classList.toggle("show", !loaded);
      }

      function renderRewardOrbit(rows) {
        if (!rewardOrbitEl) return;
        if (rewardOrbitApi && typeof rewardOrbitApi.renderRewardOrbit === "function") {
          rewardOrbitApi.renderRewardOrbit({
            orbitEl: rewardOrbitEl,
            rows,
            scale: getCurrentUiScale(),
            viewportW: Number(window.innerWidth || 0),
            escapeHtml,
            t,
            tFmt,
            coalesce,
            onAfterRender: syncRewardCharacterImageState,
          });
          return;
        }

        const srcRows = Array.isArray(rows) ? rows : [];
        rewardOrbitEl.style.setProperty("--rewardNodeWidth", "188px");
        if (srcRows.length === 0) {
          rewardOrbitEl.innerHTML = `<div class="rewardOrbitEmpty small">${escapeHtml(t("rewards.none", "(No rewards yet)"))}</div>`;
          syncRewardCharacterImageState();
          return;
        }
        rewardOrbitEl.innerHTML = "";
        syncRewardCharacterImageState();
      }

      function renderRewards() {
        const meta = `${t("rewards.rolls", "Rolls")}: ${coalesce(rewards.rolls, 0)} | ${t("rewards.every", "Every")}: ${coalesce(
          rewards.rewardEvery,
          "?"
        )} | ${t("rewards.mult", "Mult")}: ${coalesce(rewards.rewardMultiplier, "?")}`;
        rewardMeta.textContent = meta;
        const rows = (rewards.totals || []).slice().sort((a, b) => (a.label || "").localeCompare(b.label || ""));
        renderRewardOrbit(rows);
        rewardsBody.innerHTML =
          rows.length === 0
            ? `<tr><td colspan="2" class="small">${escapeHtml(t("rewards.none", "(No rewards yet)"))}</td></tr>`
            : rows
                .map(
                  (it, idx) => `
          <tr class="dataRow ${idx % 2 === 0 ? "rowOdd" : ""}">
            <td>${escapeHtml(it.label || "Unknown")}</td>
            <td class="mono colCount">${escapeHtml(it.display || String(coalesce(it.total, 0)))}</td>
          </tr>`
                )
                .join("");
      }

      function renderSettings() {
        if (!settings) return;
        setToggleKeyInputFromDik(coalesce(settings.toggleKeyCode, 0) >>> 0);
        if (langSelectEl) {
          langSelectEl.value = coalesce(settings.languageOverride, "auto");
          syncLangDropdown();
        }
        document.getElementById("setPauseGame").checked = !!settings.uiPauseGame;
        document.getElementById("setDisableFocusMenu").checked = !!settings.uiDisableFocusMenu;
        document.getElementById("setDestroyOnClose").checked = !!settings.uiDestroyOnClose;
        document.getElementById("setNormalize").checked = !!settings.normalizeRegistration;
        document.getElementById("setRequireTccDisplayed").checked = !!settings.requireTccDisplayed;
        document.getElementById("setProtectFav").checked = !!settings.protectFavorites;
        document.getElementById("setLootNotify").checked = !!settings.enableLootNotify;
        document.getElementById("setRewardsEnabled").checked = !!settings.enableRewards;
        document.getElementById("setRewardEvery").value = coalesce(settings.rewardEvery, 10);
        document.getElementById("setRewardMult").value = coalesce(settings.rewardMultiplier, 1.0);
        document.getElementById("setSkillRewards").checked = !!settings.allowSkillRewards;

        // Input scale: prefer localStorage override, otherwise use settings value.
        const desiredInputScale = parseFloat(String(coalesce(settings.uiInputScale, 1.0)));
        if (!inputScaleHasLocal) {
          setInputScale(isFinite(desiredInputScale) && desiredInputScale > 0 ? desiredInputScale : 1.0, { persist: false });
          // If auto UI scaling is enabled, re-apply using the (potentially updated) inputScale hint.
          applyUiScaleFromPrefs();
        } else {
          syncInputScaleControls();
        }

        if (perfModeEl) perfModeEl.value = perfMode;
        applyPerfModeFromPrefs();
      }

      function escapeHtml(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      // Native callbacks (C++ -> JS)
      function onNativeState(nextState) {
        state = nextState || {};
        uiLang = typeof state.language === "string" ? state.language : uiLang;
        document.documentElement.lang = uiLang === "ko" ? "ko" : "en";
        applyI18n();
        renderStatus();
        renderQuick();
        renderRegistered();
        renderRewards();
      }

      function onNativeInventory(nextInventoryPage) {
        inventoryPage = nextInventoryPage;
        resetVirtualWindow(quickVirtual);
        renderQuick();
        schedulePostRefreshVirtualResync();
      }

      function onNativeRegistered(nextRegistered) {
        registered = nextRegistered;
        resetVirtualWindow(regVirtual);
        renderRegistered();
        schedulePostRefreshVirtualResync();
      }

      function onNativeRewards(nextRewards) {
        rewards = nextRewards && typeof nextRewards === "object" ? nextRewards : { totals: [] };
        renderRewards();
      }

      function onNativeSettings(nextSettings) {
        settings = nextSettings;
        renderSettings();

        // If the user explicitly overrides the language, apply UI i18n immediately
        // (state.language may update slightly later after native localization reload).
        const o = settings && typeof settings.languageOverride === "string" ? settings.languageOverride : "";
        if (o === "en" || o === "ko") {
          uiLang = o;
          document.documentElement.lang = uiLang === "ko" ? "ko" : "en";
          applyI18n();
        }
      }

      function onNativeToast(toastPayload) {
        const payload = toastPayload || {};
        showToast(payload.level || "info", payload.message || "");
      }

      if (interopBridgeApi && typeof interopBridgeApi.installNativeCallbacks === "function") {
        interopBridgeApi.installNativeCallbacks({
          windowObj: window,
          coalesce,
          onState: onNativeState,
          onInventory: onNativeInventory,
          onRegistered: onNativeRegistered,
          onRewards: onNativeRewards,
          onSettings: onNativeSettings,
          onToast: onNativeToast,
        });
      } else {
        // Fallback when interop module is unavailable.
        window.copng_setState = (jsonStr) => {
          let payload = {};
          try {
            payload = typeof jsonStr === "string" ? JSON.parse(jsonStr) : jsonStr;
          } catch {}
          onNativeState(payload || {});
        };
        window.copng_setInventory = (jsonStr) => {
          let payload = null;
          try {
            payload = typeof jsonStr === "string" ? JSON.parse(jsonStr) : jsonStr;
          } catch {}
          if (Array.isArray(payload)) {
            onNativeInventory({ page: 0, pageSize: payload.length, total: payload.length, hasMore: false, items: payload });
          } else if (payload && typeof payload === "object") {
            onNativeInventory({
              page: coalesce(payload.page, 0) >>> 0,
              pageSize: coalesce(payload.pageSize, 200) >>> 0,
              total: coalesce(payload.total, 0) >>> 0,
              hasMore: !!payload.hasMore,
              items: Array.isArray(payload.items) ? payload.items : [],
            });
          } else {
            onNativeInventory({ page: 0, pageSize: 200, total: 0, hasMore: false, items: [] });
          }
        };
        window.copng_setRegistered = (jsonStr) => {
          let payload = [];
          try {
            payload = typeof jsonStr === "string" ? JSON.parse(jsonStr) : jsonStr;
          } catch {}
          onNativeRegistered(Array.isArray(payload) ? payload : []);
        };
        window.copng_setRewards = (jsonStr) => {
          let payload = { totals: [] };
          try {
            payload = typeof jsonStr === "string" ? JSON.parse(jsonStr) : jsonStr;
          } catch {}
          onNativeRewards(payload);
        };
        window.copng_setSettings = (jsonStr) => {
          let payload = null;
          try {
            payload = typeof jsonStr === "string" ? JSON.parse(jsonStr) : jsonStr;
          } catch {}
          onNativeSettings(payload);
        };
        window.copng_toast = (jsonStr) => {
          try {
            const obj = typeof jsonStr === "string" ? JSON.parse(jsonStr) : jsonStr;
            onNativeToast({ level: obj.level || "info", message: obj.message || "" });
          } catch {
            onNativeToast({ level: "info", message: String(jsonStr || "") });
          }
        };
      }

      // UI wiring
      function requestInventoryPage(page) {
        const pageSize = coalesce(inventoryPage.pageSize, 200) >>> 0;
        safeCall("copng_requestInventory", { page: page >>> 0, pageSize: pageSize > 0 ? pageSize : 200 });
      }

      let quickRenderTimer = null;
      let regRenderTimer = null;
      function scheduleRenderQuick() {
        if (quickRenderTimer) clearTimeout(quickRenderTimer);
        quickRenderTimer = setTimeout(() => {
          quickRenderTimer = null;
          renderQuick();
        }, 70);
      }
      function scheduleRenderRegistered() {
        if (regRenderTimer) clearTimeout(regRenderTimer);
        regRenderTimer = setTimeout(() => {
          regRenderTimer = null;
          renderRegistered();
        }, 70);
      }

      function setQuickSelected(nextId) {
        const id = Number(nextId) >>> 0;
        if (!id) return;
        if (quickSelectedId === id) return;
        const prev = quickSelectedId;
        quickSelectedId = id;
        if (prev) {
          const prevRow = quickBody.querySelector(`tr[data-row-id="${prev}"]`);
          if (prevRow) prevRow.classList.remove("selected");
        }
        const row = quickBody.querySelector(`tr[data-row-id="${id}"]`);
        if (row) row.classList.add("selected");
      }

      function scrollQuickIndexIntoView(idx) {
        if (!rootScrollEl || !quickBody) return;
        if (isFinite(idx)) idx = Number(idx);
        if (!isFinite(quickVirtual.tbodyTopPx) || !isFinite(quickVirtual.rowHeightPx) || quickVirtual.rowHeightPx <= 0) {
          const s = getCurrentUiScale();
          quickVirtual.rowHeightPx = QUICK_ROW_BASE_PX * s;
          quickVirtual.tbodyTopPx = getOffsetTopInRoot(rootScrollEl, quickBody);
        }

        const uiScale = getCurrentUiScale();
        const rowHeight = quickVirtual.rowHeightPx;
        const tbodyTop = quickVirtual.tbodyTopPx;
        const rowTop = tbodyTop + idx * rowHeight;
        const rowBottom = rowTop + rowHeight;
        const viewTop = Number(rootScrollEl.scrollTop || 0);
        const viewBottom = viewTop + Number(rootScrollEl.clientHeight || 900);

        if (rowTop < viewTop) rootScrollEl.scrollTop = Math.max(0, rowTop - 4 * uiScale);
        else if (rowBottom > viewBottom) rootScrollEl.scrollTop = Math.max(0, rowBottom - Number(rootScrollEl.clientHeight || 900) + 4 * uiScale);
      }

      function onQuickBodyClick(e) {
        // Ultralight/PrismaUI may dispatch clicks with a Text node target; parentElement isn't always available.
        // Walk via parentNode and only read tagName when it's an Element node.
        let node = e.target;
        while (node && node !== quickBody) {
          if (node.nodeType === 1) {
            const el = node;
            if (el.tagName === "BUTTON" && el.getAttribute("data-action") === "reg") {
              const id = Number(el.getAttribute("data-id"));
              if (isFinite(id) && id > 0) {
                setQuickSelected(id);
                safeCall("copng_log", { level: "info", message: `UI register click: ${toHex32(id >>> 0)}` });
                safeCall("copng_registerItem", { formId: id >>> 0 });
              }
              return;
            }
            if (el.tagName === "TR" && el.getAttribute("data-row-id")) {
              const id = Number(el.getAttribute("data-row-id"));
              if (isFinite(id) && id > 0) {
                setQuickSelected(id);
              }
              return;
            }
          }
          node = node.parentNode;
        }
      }
      // (renderSettings/escapeHtml/native callbacks/wiring moved earlier)

      function saveSettingsFromUi() {
        const keyRaw = (document.getElementById("setToggleKey").value || "").trim();
        let key = KC && KC.parseKeybindInput ? KC.parseKeybindInput(keyRaw) : null;
        if (key == null) {
          key = getToggleKeyDik();
          setToggleKeyInputFromDik(key);
          showToast("warn", `${t("toast.bindKeyUnknown", "Unsupported key.")}`);
        }
        const payload = {
          toggleKeyCode: (key >>> 0) & 0xff,
          languageOverride: document.getElementById("setLang").value,
          uiPauseGame: document.getElementById("setPauseGame").checked,
          uiDisableFocusMenu: document.getElementById("setDisableFocusMenu").checked,
          uiDestroyOnClose: document.getElementById("setDestroyOnClose").checked,
          uiInputScale: clamp(inputScale, 0.5, 3.0),
          normalizeRegistration: document.getElementById("setNormalize").checked,
          requireTccDisplayed: document.getElementById("setRequireTccDisplayed").checked,
          protectFavorites: document.getElementById("setProtectFav").checked,
          enableLootNotify: document.getElementById("setLootNotify").checked,
          enableRewards: document.getElementById("setRewardsEnabled").checked,
          rewardEvery: parseInt(document.getElementById("setRewardEvery").value, 10) || 10,
          rewardMultiplier: parseFloat(document.getElementById("setRewardMult").value) || 1.0,
          allowSkillRewards: document.getElementById("setSkillRewards").checked,
        };
        safeCall("copng_saveSettings", payload);
      }

      const onManualScaleChange = (raw) => {
        uiScaleMode = "manual";
        const v = parseFloat(String(raw || ""));
        uiScaleManual = isFinite(v) && v > 0 ? clamp(v, 1.0, 3.0) : uiScaleManual;
        applyManualUiScale();
        saveUiScalePrefs();
        syncUiScaleControls();
      };

      // Input scale (click/hitbox correction)
      const onInputScaleChange = (raw, { toast = false } = {}) => {
        setInputScale(raw, { persist: true, toast: toast });
      };

      function onPerfModeChanged(raw) {
        const v = String(raw || "");
        perfMode = v === "on" || v === "off" ? v : "auto";
        savePerfModePref();
        applyPerfModeFromPrefs();
      }

      function onUiScaleModeChanged(raw) {
        uiScaleMode = raw === "manual" ? "manual" : "auto";
        if (uiScaleMode === "manual") {
          uiScaleManual = clamp(getCurrentUiScale(), 1.0, 3.0);
        }
        saveUiScalePrefs();
        applyUiScaleFromPrefs();
      }

      if (uiWiringApi && typeof uiWiringApi.installUIWiring === "function") {
        uiWiringApi.installUIWiring({
          documentObj: document,
          windowObj: window,
          rootScrollEl,
          quickBody,
          rewardCharacterImgEl,
          invPageSizeEl,
          btnInvPrev,
          btnInvNext,
          btnCaptureToggleKeyEl,
          langBtnEl,
          langMenuEl,
          langSelectEl,
          uiScaleModeEl,
          uiScaleRangeEl,
          uiScaleNumberEl,
          perfModeEl,
          inputScaleRangeEl,
          inputScaleNumberEl,
          inputScalePresetEl,
          safeCall,
          setTab,
          syncRewardCharacterImageState,
          requestInventoryPage,
          getInventoryPage: () => inventoryPage,
          setInventoryPageSize: (next) => {
            inventoryPage.pageSize = next;
          },
          showConfirm,
          t,
          scheduleRenderQuick,
          scheduleRenderRegistered,
          scheduleVirtualRender,
          renderRewards,
          onQuickBodyClick,
          onSaveSettings: saveSettingsFromUi,
          updateToggleKeyResolved,
          setCaptureToggleKey: (next) => {
            captureToggleKey = !!next;
          },
          showToast,
          closeLangMenu,
          openLangMenu,
          syncLangDropdown,
          isLangMenuOpen: () => langMenuOpen,
          loadUiScalePrefs,
          syncUiScaleControls,
          applyUiScaleFromPrefs,
          syncInputScaleControls,
          scheduleAutoUiScale,
          getPerfMode: () => perfMode,
          onPerfModeChanged,
          onUiScaleModeChanged,
          onManualScaleChange,
          onInputScaleChange,
        });
      }

      function installInputCorrectionFallback() {
        const rootEl = rootScrollEl;
        if (!rootEl) return;

        const INTERACTIVE_SEL = "button, input, select, textarea, a, [role='button'], [data-action], tr[data-row-id]";
        const isElementNode = (node) => !!(node && node.nodeType === 1);
        const pickInteractiveElement = (el) => {
          if (!isElementNode(el)) return null;
          if (el.matches && el.matches(INTERACTIVE_SEL)) return el;
          if (el.closest) return el.closest(INTERACTIVE_SEL);
          return null;
        };
        const makeMouseEventLike = (e, pt) =>
          new MouseEvent("click", {
            bubbles: true,
            cancelable: true,
            composed: true,
            view: window,
            detail: e.detail || 0,
            screenX: e.screenX || 0,
            screenY: e.screenY || 0,
            clientX: pt.x,
            clientY: pt.y,
            button: e.button || 0,
            buttons: e.buttons || 1,
            ctrlKey: !!e.ctrlKey,
            shiftKey: !!e.shiftKey,
            altKey: !!e.altKey,
            metaKey: !!e.metaKey,
          });

        let lastWheelTs = 0;
        const wheelNow = (e) => {
          const ts = typeof e.timeStamp === "number" && isFinite(e.timeStamp) ? e.timeStamp : 0;
          if (ts > 0) return ts;
          if (typeof performance !== "undefined" && performance.now) return performance.now();
          return Date.now();
        };
        const normalizeWheelDelta = (e, container) => {
          let dy = Number(e.deltaY || 0);
          if (!isFinite(dy) || dy === 0) return 0;

          const mode = Number(e.deltaMode || 0);
          if (mode === 1) dy *= 16;
          else if (mode === 2) dy *= Number(container.clientHeight || 800);

          const uiScale = clamp(getCurrentUiScale(), 1.0, 3.0);
          const abs = Math.abs(dy);
          const now = wheelNow(e);
          const dt = lastWheelTs > 0 ? now - lastWheelTs : 999;
          lastWheelTs = now;

          if (abs > 0 && abs < 12 && dt > 24) dy = Math.sign(dy) * 60 * uiScale;
          else if (abs < 40) dy = dy * 1.5 * uiScale;
          else dy = dy * uiScale;

          const maxStep = Number(container.clientHeight || 800) * 0.45;
          return clamp(dy, -maxStep, maxStep);
        };

        rootEl.addEventListener(
          "wheel",
          (e) => {
            if (!e || e.isTrusted === false) return;
            const maxScroll = Math.max(0, rootEl.scrollHeight - rootEl.clientHeight);
            if (maxScroll <= 0) return;
            const deltaPx = normalizeWheelDelta(e, rootEl);
            if (!isFinite(deltaPx) || deltaPx === 0) return;
            if (e.preventDefault) e.preventDefault();
            if (e.stopPropagation) e.stopPropagation();
            rootEl.scrollTop = clamp(rootEl.scrollTop + deltaPx, 0, maxScroll);
          },
          { passive: false }
        );

        let lastMouseupFixed = { t: 0, x: -9999, y: -9999 };
        const nowMs = () => {
          try {
            return Date.now();
          } catch {
            return 0;
          }
        };

        document.addEventListener(
          "mouseup",
          (e) => {
            if (!e || e.isTrusted === false) return;
            if (e.button !== undefined && e.button !== 0) return;
            if (isElementNode(e.target)) return;

            const w = Number(window.innerWidth || 0);
            const h = Number(window.innerHeight || 0);
            if (!isFinite(w) || !isFinite(h) || w <= 0 || h <= 0) return;

            const sx = clamp(inputScale, 0.5, 3.0);
            const needsScale = isFinite(sx) && Math.abs(sx - 1.0) >= 0.01;
            const cx = Number(e.clientX || 0);
            const cy = Number(e.clientY || 0);
            const clampPt = (pt) => ({
              x: clamp(Math.round(pt.x), 0, Math.max(0, w - 1)),
              y: clamp(Math.round(pt.y), 0, Math.max(0, h - 1)),
            });

            const candidates = [{ pt: clampPt({ x: cx, y: cy }) }];
            if (needsScale) {
              candidates.push({ pt: clampPt({ x: cx * sx, y: cy * sx }) });
              candidates.push({ pt: clampPt({ x: cx / sx, y: cy / sx }) });
            }

            let best = null;
            for (const c of candidates) {
              const raw = document.elementFromPoint(c.pt.x, c.pt.y);
              const picked = pickInteractiveElement(raw);
              if (!picked) continue;
              if (!rootEl.contains(picked)) continue;
              best = { target: picked, pt: c.pt };
              break;
            }
            if (!best) return;

            lastMouseupFixed = { t: nowMs(), x: Math.round(cx), y: Math.round(cy) };
            best.target.dispatchEvent(makeMouseEventLike(e, best.pt));
          },
          true
        );

        document.addEventListener(
          "click",
          (e) => {
            const fixedAge = nowMs() - (lastMouseupFixed.t || 0);
            if (fixedAge < 0 || fixedAge >= 250) return;

            const cx0 = Math.round(Number(e.clientX || 0));
            const cy0 = Math.round(Number(e.clientY || 0));
            if (Math.abs(cx0 - lastMouseupFixed.x) <= 1 && Math.abs(cy0 - lastMouseupFixed.y) <= 1) {
              if (e.preventDefault) e.preventDefault();
              if (e.stopImmediatePropagation) e.stopImmediatePropagation();
              else if (e.stopPropagation) e.stopPropagation();
            }
          },
          true
        );
      }

      // Initial pull
      safeCall("copng_requestState", {});
      safeCall("copng_getSettings", {});
      // High DPI click correction + direct wheel scrolling are isolated in a
      // dedicated module to keep this bootstrap script focused on state/render.
      if (inputCorrectionApi && typeof inputCorrectionApi.installInputCorrection === "function") {
        inputCorrectionApi.installInputCorrection({
          documentObj: document,
          windowObj: window,
          rootEl: rootScrollEl,
          clamp,
          getCurrentUiScale,
          getInputScale: () => inputScale,
        });
      } else {
        safeCall("copng_log", {
          level: "warn",
          message: "input_correction.js unavailable; using fallback input correction",
        });
        installInputCorrectionFallback();
      }

      // Emergency close + hotkeys/shortcuts live in a separate module to keep index.html maintainable.
      if (inputShortcutsApi && typeof inputShortcutsApi.installKeydownHandler === "function") {
        inputShortcutsApi.installKeydownHandler({
          KC,
          t,
          showToast,
          safeCall,
          setTab,
          setInputScale,
          getInputScale: () => inputScale,
          getToggleKeyDik,
          setToggleKeyInputFromDik,
          formatToggleKeyDisplay,
          getCaptureToggleKey: () => captureToggleKey,
          setCaptureToggleKey: (next) => {
            captureToggleKey = !!next;
          },
          isLangMenuOpen: () => langMenuOpen,
          closeLangMenu,
          getQuickVisibleIds: () => quickVisibleIds,
          getQuickSelectedId: () => quickSelectedId,
          setQuickSelected,
          scrollQuickIndexIntoView,
          scheduleVirtualRender,
          getKeyNavRaf: () => keyNavRaf,
          setKeyNavRaf: (next) => {
            keyNavRaf = next;
          },
          toHex32,
          documentObj: document,
          windowObj: window,
          requestAnimationFrameFn: requestAnimationFrame,
        });
      } else {
        // Last-resort fallback: keep ESC close available even if module loading fails.
        window.addEventListener("keydown", (e) => {
          const key = String((e && e.key) || "");
          const code = String((e && e.code) || "");
          const keyCode = Number((e && (e.keyCode || e.which)) || 0) || 0;
          const isEscape = key === "Escape" || code === "Escape" || keyCode === 27;
          if (!isEscape) return;
          if (e && e.preventDefault) e.preventDefault();
          safeCall("copng_requestToggle", {});
        });
      }

      safeCall("copng_log", { level: "info", message: "UI loaded" });
    </script>
  </body>
</html>
